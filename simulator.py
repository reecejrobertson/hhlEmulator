import sys
sys.path.insert(0, '../intel-qs/build/lib') # Change this to match your installation location.
import intelqs_py as simulator
import numpy as np
from matplotlib import pyplot as plt
import time

# TODO: Validate that this scales properly
def computeQPERotations(A, numQubits):
    '''
    Compute the single qubit gates needed in the QPE algorithm.
    Parameters:
        A (np.ndarray)  : The A matrix.
        numQubits (int) : The total number of qubits to use.
    Returns:
        A lsit of the QPE rotation matrices, and a list of the IQPE matrices.
    '''

    # Get the eigenvalues and eigenvectors and sort them by eigenvalue size.
    evals, evecs = np.linalg.eig(A)
    idx = evals.argsort() 
    evals = evals[idx]
    evecs = evecs[:, idx]

    # Compute the diagonal matrix hamiltonian.
    lambdaHat = 1   # FIXME: This probably needs to change.
    t = 2 * np.pi * lambdaHat / (2**(numQubits-2) * evals[0])
    Udiag = np.diag(np.exp(1j * evals * t))

    # Create a list to hold the QPE and IQPE rotation matrices.
    qpeRotations = []
    qpeInvRotations = []

    # Populate the matrices with successive powers of the diagonal matrix.
    for i in range(numQubits-2):
        Ui = evecs.T @ np.linalg.matrix_power(Udiag, 2**i) @ evecs
        qpeRotations.append(Ui)
        qpeInvRotations.append(np.linalg.inv(Ui))

    # Return both lists.
    return qpeRotations, qpeInvRotations

def computeQFTRotations(numQubits):
    return QFTRotationsHelper(numQubits), QFTRotationsHelper(numQubits, True)

def QFTRotationsHelper(numQubits, inverse=False):
    rotations = []
    sign = -1 if inverse else 1
    for n in range(2, numQubits-1):
        rotations.append(
            np.array(
                [[1, 0], [0, np.exp(sign*1j*2*np.pi/2**n)]],
                dtype=complex
            )
        )
    return rotations

def simulateIQFT(psi, numQubits, rotations):
    for i in range(numQubits-2, 0, -1):
        psi.ApplyHadamard(i)
        for j in range(1, i):
            psi.ApplyControlled1QubitGate(j, i, rotations[i-j-1])
    for i in range(1, numQubits//2):
        psi.ApplySwap(i, (numQubits-1)-i)
    return psi

def simulateQFT(psi, numQubits, invRotations):
    for i in range(numQubits//2-1, 0, -1):
        psi.ApplySwap(i, (numQubits-1)-i)
    for i in range(1, numQubits-1):
        psi.ApplyHadamard(i)
        for j in range(numQubits-2, i, -1):
            psi.ApplyControlled1QubitGate(j, i, invRotations[j-i-1])
    return psi

def simulateQPE(psi, numQubits, qpeRotations, qftInvRotations):
    for i in range(1, numQubits-1):
        psi.ApplyHadamard(i)

    # Apply controlled-U**i operations
    for i in range(1, numQubits-1):
        psi.ApplyControlled1QubitGate(i, numQubits-1, qpeRotations[i-1])

    # IQFT
    psi = simulateIQFT(psi, numQubits, qftInvRotations)
    
    return psi

def simulateIQPE(psi, numQubits, qpeInvRotations, qftRotations):
    # IQFT
    psi = simulateQFT(psi, numQubits, qftRotations)

    # Apply controlled-U**i operations
    for i in range(numQubits-2, 0, -1):
        psi.ApplyControlled1QubitGate(i, numQubits-1, qpeInvRotations[i-1])

    for i in range(1, numQubits-1):
        psi.ApplyHadamard(i)
    
    return psi

# TODO: FIXME
def simulateYRotations(psi, numQubits):
    for i in range(1, numQubits-1):
        psi.ApplyCRotationY(i, 0, 2*np.arcsin(1/2**(i-1)))
    return psi

def measure(psi, target):
    # Compute the probability of qubit 0 being in state |1>.
    prob = psi.GetProbability(target)
    result = None

    # Draw random number in [0,1)
    r = np.random.rand()
    if r < prob:
        # Collapse the wavefunction according to qubit 0 being in |1>.
        psi.CollapseQubit(target, True)
        result = '1'
    else:
        # Collapse the wavefunction according to qubit 0 being in |0>
        psi.CollapseQubit(target, False)
        result = '0'

    # In both cases we need to renormalize the wavefunction.
    psi.Normalize()

    return psi, result

def simulateHHL(A, b, numQubits=4, shots=2048, figfile='simulator.png', dpi=300):
    '''
    A function that simulates the HHL algorithm using the process explained in
    section II of https://arxiv.org/pdf/2108.09004.pdf.
    Parameters:
        A (np.ndarray)  : The matrix A from the system Ax = b.
        b (np.ndarray)  : The vector b from the system Ax = b.
        shots (int)     : The number of shots to run.
        figfile (string): The file name to save the histogram under.
        dpi (int)       : The dpi of the histogram.
    Returns:
        An estimation of x as given by the HHL algorith.
        Also returns the time taken to perform the emulation.
        Finally saves a plot of the distribution generated by the algorithm.
    '''

    # Define the initial state of psi and get the QPE and QFT matrices.
    initialSate = 0
    qftGates, iqftGates = computeQFTRotations(numQubits)
    qpeGates, iqpeGates = computeQPERotations(A, numQubits)

    # Define a dictionary to hold the experimental results.
    probs = {'00': 0, '01': 0, '10': 0, '11': 0}

    # Note the time before starting the simulation proper.
    startTime = time.time()

    # For each shot:
    for i in range(shots):

        # Initialize a quantum system.
        psi = simulator.QubitRegister(numQubits, 'base', initialSate, 0)

        # Intialize the target (last) qubit to the b state.
        psi.ApplyPauliX(numQubits-1)    # FIXME: This should use b!

        # Apply the QPE to the target qubit (involving the c qubits).
        psi = simulateQPE(psi, numQubits, qpeGates, iqftGates)

        # Apply the controlled Y rotations to the anscilla (top) qubit.
        psi.ApplyCRotationY(1, 0, np.pi)
        psi.ApplyCRotationY(2, 0, np.pi/3.)

        # Apply the IQPE to the target qubit.
        psi = simulateIQPE(psi, numQubits, iqpeGates, qftGates)

        # Measure the anscilla and target qubit, and track the result.
        psi, rightResult = measure(psi, target=0)
        psi, leftResult = measure(psi, target=numQubits-1)
        probs[leftResult + rightResult] += 1
    
    # Compute the total amount of time it took to perform the simulation.
    elapsedTime = time.time() - startTime

    # Compute the percentage of each measurement result.
    for key in probs:
        probs[key] /= shots


    # Plot the histogram with exact y-values on top of the bars.
    fig = plt.figure
    plt.bar(range(len(probs)), list(probs.values()), align='center')
    plt.xticks(range(len(probs)), list(probs.keys()))
    xlocs, xlabs = plt.xticks()
    for i, v in enumerate(probs.values()):
        plt.text(xlocs[i] - 0.2, v + .007, str(v))
    plt.xlabel('Measurement Result')
    plt.ylabel('Probability')
    plt.title(
        'Simulation with A=['
        + np.array_str(A[0], precision=2,) + ','
        + np.array_str(A[1], precision=2) + '], b='
        + np.array_str(b, precision=2)
    )
    plt.savefig('plots/' + figfile, dpi=dpi)

    # Return the estimation of x.
    return np.array([
        probs['01'] / (probs['01'] + probs['11']),
        probs['11'] / (probs['01'] + probs['11'])
    ]), elapsedTime




# def toffoli(psi, a, b, c):
#     psi.ApplyHadamard(c)
#     psi.ApplyCPauliX(b, c)
#     psi.ApplyRotationZ(c, -np.pi/4.)
#     psi.ApplyCPauliX(a, c)
#     psi.ApplyRotationZ(c, np.pi/4.)
#     psi.ApplyCPauliX(b, c)
#     psi.ApplyRotationZ(c, -np.pi/4.)
#     psi.ApplyCPauliX(a, c)
#     psi.ApplyRotationZ(b, np.pi/4.)
#     psi.ApplyRotationZ(c, np.pi/4.)
#     psi.ApplyCPauliX(a, b)
#     psi.ApplyHadamard(c)
#     psi.ApplyRotationZ(a, np.pi/4.)
#     psi.ApplyRotationZ(b, -np.pi/4.)
#     psi.ApplyCPauliX(a, b)
#     return psi




# def simulateHHL(A, b, numQubits=4, shots=1000):
#     initialSate = 0
#     qftGates, iqftGates = computeQFTRotations(numQubits)
#     qpeGates, iqpeGates = computeQPERotations(A, numQubits)

#     probs = {'00': 0, '01': 0, '10': 0, '11': 0}

#     for i in range(shots):

#         # Initialize a quantum system
#         psi = simulator.QubitRegister(5, 'base', initialSate, 0)

#         # FIXME: This should use b!
#         psi.ApplyPauliX(3)

#         psi = simulateQPE(psi, numQubits, qpeGates, iqftGates)

#         # Controlled Y rotations
#         # for i in range(1, numQubits-1):
#         # psi = simulateYRotations(psi, numQubits)
#         psi.ApplyCRotationY(1, 0, np.pi)#2 * np.arcsin(1/2.))
#         psi = toffoli(psi, 1, 2, 4)
#         psi.ApplyCRotationY(4, 0, np.pi/3.)#2 * np.arcsin(1/3.))
#         psi = toffoli(psi, 1, 2, 4)

#         psi = simulateIQPE(psi, numQubits, iqpeGates, qftGates)

#         psi, rightResult = measure(psi, target=0)
#         psi, leftResult = measure(psi, target=numQubits-1)

#         probs[leftResult + rightResult] += 1

#     for key in probs:
#         probs[key] /= shots

#     plt.bar(range(len(probs)), list(probs.values()), align='center')
#     plt.xticks(range(len(probs)), list(probs.keys()))
#     xlocs, xlabs = plt.xticks()
#     for i, v in enumerate(probs.values()):
#         plt.text(xlocs[i] - 0.2, v + .007, str(v))
#     plt.xlabel('Measurement Result')
#     plt.ylabel('Probability')
#     plt.show()

#     return np.array([probs['01'] / (probs['01'] + probs['11']), probs['11'] / (probs['01'] + probs['11'])])

# A = np.array([[13/2., -1/2.], [-1/2., 13/2]])
# b = np.array([0, 1])
# estimate = simulateHHL(A, b, numQubits=4, shots=5000)
# print(estimate)
# total = np.abs(1./84.)**2 + np.abs(13./84.)**2
# print(np.array([np.abs(1./84.)**2 / total, np.abs(13./84.)**2 / total]))

# # TODO: cry(2, 0, pi)
# # TODO: toffoliry(1,2, 0, pi/3)
# A = np.array([[5/2., -1/2.], [-1/2., 5/2]])
# b = np.array([0, 1])
# estimate = simulateHHL(A, b, numQubits=4, shots=5000)
# print(estimate)
# total = np.abs(1./12.)**2 + np.abs(5./12.)**2
# print(np.array([np.abs(1./12.)**2 / total, np.abs(5./12.)**2 / total]))
