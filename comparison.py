import numpy as np
import emulator as em
import simulator as sim

def runExperiment(
        A, b, applyRYs, t, numQubits, extraAncillas, shots=2048,
        emFig='emulator.png', simFig='simulator.png', dpi=300
    ):
    '''
    A function that simulates the HHL algorithm using the process explained in
    section II of https://arxiv.org/pdf/2108.09004.pdf.
    Parameters:
        A (np.ndarray)      : The matrix A from the system Ax = b.
        b (np.ndarray)      : The vector b from the system Ax = b.
        applyRYs (func)     : A function to apply the controlled y rotations.
        t (float)           : A value needed for the QPE matrices.
        numQubits (int)     : The number of qubits used in the algorithm.
        extraAncillas (int) : The number of extra ancillas (used in applyRYs).
        shots (int)         : The number of shots to run.
        emFig (string)      : The name to save the emulator histogram under.
        simFig (string)     : The name to save the simulator histogram under.
        dpi (int)           : The dpi of the histogram.
    Returns:
        An estimation of x as given by the HHL algorith.
        Also returns the time taken to perform the emulation.
        Finally saves a plot of the distribution generated by the algorithm.
    '''
    
    print('Begin Experiment')

    # Compute the solution, the simulator estimate, and the emulator estimate.
    x = np.linalg.solve(A, b)
    actual = (x / np.linalg.norm(x))**2
    simEstimate, simTime = sim.simulateHHL(
        A, b, applyRYs, t, numQubits, extraAncillas,
        shots=shots, figfile=simFig, dpi=dpi
    )
    emEstimate, emTime = em.emulateHHL(
        A, b, shots=shots, figfile=emFig, dpi=dpi
    )

    # Print results.
    print('A=['
        + np.array_str(A[0], precision=2,) + ','
        + np.array_str(A[1], precision=2) + '], b='
        + np.array_str(b, precision=2)
    )
    print('Actual x\t:', actual)
    print('Simulated x\t:', simEstimate)
    print('Emulated x\t:', emEstimate)
    print('Sim Time\t:', simTime)
    print('Em Time \t:', emTime)
    print('Sim Avg Time\t:', simTime/shots)
    print('Em Avg Time\t:', emTime/shots)
    print('End Experiment')
    print()

def applyToffoli(psi, a, b, c):
    '''
    Apply a Toffoli gate to a quantum register.
    Parameters:
        psi (QuantumRegister)   : A quantum state.
        a (int)                 : The index of the first control qubit.
        b (int)                 : The index of the second control qubit.
        c (int)                 : The index of the target qubit.
    Returns:
        The QuantumRegister after the Toffoli gate has been applied.
    '''

    # Apply the Toffoli using the decomposition in Nielsen and Chuang.
    psi.ApplyHadamard(c)
    psi.ApplyCPauliX(b, c)
    psi.ApplyRotationZ(c, -np.pi/4.)
    psi.ApplyCPauliX(a, c)
    psi.ApplyRotationZ(c, np.pi/4.)
    psi.ApplyCPauliX(b, c)
    psi.ApplyRotationZ(c, -np.pi/4.)
    psi.ApplyCPauliX(a, c)
    psi.ApplyRotationZ(b, -np.pi/4.)
    psi.ApplyRotationZ(c, np.pi/4.)
    psi.ApplyCPauliX(a, b)
    psi.ApplyHadamard(c)
    psi.ApplyRotationZ(b, -np.pi/4.)
    psi.ApplyCPauliX(a, b)
    psi.ApplyRotationZ(a, np.pi/4.)
    psi.ApplyRotationZ(b, np.pi/2.)

    # Return psi.
    return psi

def RY1(psi):
    '''
    The controlled y-rotation gates for experiment 1.
    Parameters:
        psi (QuantumRegister)   : A quantum state.
    Returns:
        The QuantumRegister after the y-rotations have been applied.
    '''

    # Apply the needed y rotations and return.
    psi.ApplyCRotationY(1, 0, np.pi)
    psi.ApplyCRotationY(2, 0, np.pi/3.)
    return psi

def RY2(psi):
    '''
    The controlled y-rotation gates for experiment 2.
    Parameters:
        psi (QuantumRegister)   : A quantum state.
    Returns:
        The QuantumRegister after the y-rotations have been applied.
    '''

    # Apply the needed y rotations and return.
    psi = applyToffoli(psi, 2, 3, 5)
    psi.ApplyCRotationY(5, 0, np.pi)
    psi = applyToffoli(psi, 2, 3, 5)
    psi = applyToffoli(psi, 1, 2, 5)
    psi = applyToffoli(psi, 3, 5, 6)
    psi.ApplyCRotationY(6, 0, np.pi/3.)
    psi = applyToffoli(psi, 3, 5, 6)
    psi = applyToffoli(psi, 1, 2, 5)
    return psi

runExperiment(np.array([[1 , -1/3], [-1/3 , 1]]), np.array([0, 1]), RY1, 3 * np.pi / 4, 4, 0, emFig='em1.png', simFig='sim1.png')
runExperiment(np.array([[13/2., -1/2.], [-1/2., 13/2]]), np.array([0, 1]), RY2, np.pi/4, 5, 2, emFig='em2.png', simFig='sim2.png')