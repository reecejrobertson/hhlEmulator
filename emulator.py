import numpy as np
import matplotlib.pyplot as plt
import time

def emulateHHL(A, b, shots=2048, figfile='emulator.png', dpi=300):
    '''
    A function that emulates the HHL algorithm using the fourth equaiton on
    page 3 of https://arxiv.org/abs/0811.3171.
    Parameters:
        A (np.ndarray)  : The matrix A from the system Ax = b.
        b (np.ndarray)  : The vector b from the system Ax = b.
        shots (int)     : The number of shots to run.
        figfile (string): The file name to save the histogram under.
        dpi (int)       : The dpi of the histogram.
    Returns:
        An estimation of x as given by the HHL algorith.
        Also returns the time taken to perform the emulation.
        Finally saves a plot of the distribution generated by the algorithm.
    '''

    # Note the time before starting the emulation proper.
    startTime = time.time()

    # Create a dict for the measure count of the states |00>, |01>, |10>, |11>.
    measure_count = {'00': 0, '01': 0, '10': 0, '11': 0}

    # Repeat the following experiment 'shots' times.
    for i in range(shots):

        # Compute the eigenvalues and eigenvectors of A.
        evals, evecs = np.linalg.eig(A)

        # Compute the coefficients to represent b in the eigenbasis of A.
        beta = np.linalg.solve(evecs, b)

        # Get c, which we take to be the minimal eigenvalue.
        c = min(evals)

        # Compute the state of the anscilla qubit as given in the fourth equation.
        a = np.array([np.sqrt(1 - c**2/evals**2), c/evals])

        # Generate the complete state according to the forth equation and normalize.
        psi = np.kron(beta * evecs, a)
        psi = psi[:,1] + psi[:,2]
        psi = psi /np.linalg.norm(psi)

        # Sample from the distribution.
        r = np.random.rand()
        if r < psi[0]**2:
            measure_count['00'] += 1
        elif r < (psi[0]**2 + psi[1]**2):
            measure_count['01'] += 1
        elif r < (psi[0]**2 + psi[1]**2 + psi[2]**2):
            measure_count['10'] += 1
        else:
            measure_count['11'] += 1

    # Compute the total amount of time it took to perform the simulation.
    elapsedTime = time.time() - startTime

    # Extract the keys and values from the dictionary.
    x_values = list(measure_count.keys())
    y_values = list(measure_count.values())

    # Calculate the probability of each measurement outcome.
    total_counts = sum(y_values)
    probabilities = [count / total_counts for count in y_values]

    # Plot the histogram with exact y-values on top of the bars.
    fig, ax = plt.subplots()
    bars = ax.bar(x_values, probabilities)
    for bar, prob in zip(bars, probabilities):
        yval = bar.get_height()
        ax.text(
            bar.get_x() + bar.get_width() / 2, yval,
            round(yval, 3), ha='center', va='bottom'
        )
    plt.xlabel('Measurement Result')
    plt.ylabel('Probability')
    plt.title(
        'Emulation with A=['
        + np.array_str(A[0], precision=2,) + ','
        + np.array_str(A[1], precision=2) + '], b='
        + np.array_str(b, precision=2)
    )
    plt.savefig('plots/' + figfile, dpi=dpi)

    # Return the estimation of x.
    return np.array([
        measure_count['01'] / (measure_count['01'] + measure_count['11']),
        measure_count['11'] / (measure_count['01'] + measure_count['11'])
    ]), elapsedTime